#!/usr/bin/env python3
import argparse
import asyncio
import contextlib
import json
import logging
import os
import re
import subprocess
from pathlib import Path

log = logging.getLogger(__name__)
logging.basicConfig(
    level=logging.DEBUG,
    datefmt='%H:%M:%S',
    format='%(asctime)s %(message)s'
)
root = os.path.dirname(__file__)
dry_run = False


def remote(cmd, host, opts='-o "StrictHostKeyChecking no"'):
    cmd = cmd.replace('"', '\\"')
    return (
        'set -e;rsync -ahv --delete -e \'ssh {opts}\' {root}/ {host}:{tmp}/;'
        'ssh {opts} {host} "cd {tmp}; {cmd}"'
        .format(tmp='/tmp/deploy', root=root, host=host, opts=opts, cmd=cmd)
    )


def sh(cmd, params=None, ssh=None, exit=True, sudo=False, sync=True):
    params = params or {}
    if sudo:
        cmd = 'sudo sh -c %r' % cmd
    if ssh:
        cmd = remote(cmd, ssh)

    log.info(cmd)
    if dry_run:
        log.info('Dry run!')
        return 0

    if sync:
        code = subprocess.call(cmd, shell=True)
        if exit and code:
            raise SystemExit(code)
        return code

    return asyncio.create_subprocess_shell(cmd)


def get_config():
    with open('config.json', 'r') as f:
        conf = f.read()
    return json.loads(conf)


def pretty_json(obj):
    return json.dumps(obj, indent=2, sort_keys=True)


def gh_push(path, clean=True, capture=True):
    import requests

    path = Path(path)
    with (path / 'request.json').open('r') as f:
        req = json.loads(f.read())

    name = req['json']['ref'].replace('refs/heads/', '')
    name = re.sub('[^\w-]', '-', name)
    logfile = path / ('%s.log' )
    params = {
        'name': name,
        'lxc': 'sd-%s' % name,
        'endpoint': 'superdesk-dev/master',
        'clean': clean or '',
        'path': path.resolve(),
        'capture': (
            (' > %s 2>&1' if capture else ' 2>&1 | tee %s')
            % (path / 'output.log')
        )
    }

    sha = req['json']['after']
    repo = req['json']['repository']
    url = repo['statuses_url'].format(sha=sha)
    data = {
        'state': 'pending',
        'target_url': 'http://test.superdesk.org/push/%s/output.log' % sha,
        'description': 'Superdesk Deploy in progress',
        'context': 'naspeh-sf/deploy/push'
    }
    conf = get_config()
    s = requests.Session()
    s.auth = tuple(conf['github_auth'].split(':'))
    resp = s.post(url, data=json.dumps(data))
    print(resp.status_code)
    print(pretty_json(resp.json()))
    if resp.status_code != 201:
        return
    code = sh(
        'name={name} '
        'lxc={lxc} '
        'endpoint={endpoint} '
        'clean={clean} '
        'path={path} '
        'bin/gh-push.sh{capture}'
        .format(**params)
    )
    update = {
        'state': 'success' if code == 0 else 'failed',
        'description': 'Superdesk Deploy passed'
    }
    data = dict(data, **update)
    resp = s.post(url, data=json.dumps(data))
    print(resp.status_code)
    print(pretty_json(resp.json()))



@contextlib.contextmanager
def run_async(func, *a, **kw):
    loop = asyncio.get_event_loop()
    yield loop.run_until_complete(func(*a, **kw))
    loop.close()


def async_tests():
    """TODO: finish async testing"""
    async def tests():
        cmd = (
            'set -ex;'
            'cd {root};'
            'lxc-stop -n {lxc} || true;'
            'lxc-stop -n {lxc_uniq} || true;'
            'lxc-destroy -n {lxc_uniq} || true;'
            'lxc-copy -n {lxc} -N {lxc_uniq};'
            'lxc-start -n {lxc_uniq};'
            'sleep 5;'
            './fire r --lxc-name={lxc_uniq} -e {endpoint} -a {action!r}'
        )
        nose_cmd = cmd.format(
            lxc_uniq='%s-nose' % params['lxc'],
            action='nose=1 do_tests',
            **params
        )
        behave_cmd = cmd.format(
            lxc_uniq='%s-behave' % params['lxc'],
            action='behave=1 do_tests',
            **params
        )
        nose = await sh(nose_cmd, sudo=True, sync=False)
        # return [await nose.wait()]
        behave = await sh(behave_cmd, sudo=True, sync=False)
        return await nose.wait(), await behave.wait()

    with run_async(tests) as codes:
        log.info('Exit codes: %s', codes)
        code = [c for c in codes if c]
        if code:
            raise SystemExit(code[0])
        return codes


def main():
    global dry_run

    parser = argparse.ArgumentParser('fire')
    cmds = parser.add_subparsers(help='commands')

    def cmd(name, **kw):
        p = cmds.add_parser(name, **kw)
        p.set_defaults(cmd=name)
        p.arg = lambda *a, **kw: p.add_argument(*a, **kw) and p
        p.exe = lambda f: p.set_defaults(exe=f) and p

        p.arg('--dry-run', action='store_true')
        return p

    def ssh(ssh, lxc_name):
        return (
            ssh or
            (lxc_name and 'root@$(sudo lxc-info -n %s -iH)' % lxc_name)
        )

    cmd('install', aliases=['i'])\
        .arg('--lxc-name')\
        .arg('--ssh')\
        .arg('-e', '--endpoint', default='superdesk/master')\
        .arg('--prepopulate', action='store_true')\
        .arg('--services', action='store_true')\
        .arg('--force-frontend', action='store_true')\
        .exe(lambda a: sh(
            'services={services} '
            'force_frontend={force_frontend} '
            'prepopulate={prepopulate} '
            'action=do_install '
            '{endpoint}'
            .format(
                services=a.services or '',
                force_frontend=a.force_frontend or '',
                prepopulate=a.prepopulate or '',
                endpoint=a.endpoint
            ),
            ssh=ssh(a.ssh, a.lxc_name)
        ))

    cmd('run', aliases=['r'])\
        .arg('--lxc-name')\
        .arg('--ssh')\
        .arg('-e', '--endpoint', default='superdesk/master')\
        .arg('-a', '--action', default='')\
        .exe(lambda a: sh(
            'action={action!r} {endpoint}'
            .format(action=a.action, endpoint=a.endpoint),
            ssh=ssh(a.ssh, a.lxc_name)
        ))

    cmd('gen-files')\
        .exe(lambda a: sh('bin/gen-files.sh'))

    cmd('lxc-init')\
        .arg('-n', '--name', default='sd0')\
        .arg('--rm', action='store_true')\
        .arg('-k', '--keys', default='/root/.ssh/id_rsa.pub')\
        .exe(lambda a: sh(
            'name={name} '
            'rm={rm} '
            'keys={keys} '
            'bin/lxc-init.sh'
            .format(name=a.name, rm=a.rm or '', keys=a.keys)
        ))

    cmd('lxc-web')\
        .arg('-n', '--name', default='sd0')\
        .arg('-d', '--domain', required=True)\
        .arg('-c', '--clean', action='store_true')\
        .exe(lambda a: sh(
            'name={name} '
            'domain={domain} '
            'clean={clean} '
            'bin/lxc-web.sh'
            .format(name=a.name, domain=a.domain, clean=a.clean or '')
        ))

    cmd('lxc-base')\
        .arg('-n', '--name', default='sd-base')\
        .exe(lambda a: sh(
            'set -ex;'
            './fire lxc-init -n {name} --rm;'
            './fire r --lxc-name={name} -e common/services.sh;'
            'lxc-stop -n {name}'
            .format(name=a.name)
        ))

    cmd('gh-push')\
        .arg('path')\
        .arg('-r', '--capture', action='store_true')\
        .arg('-c', '--clean', action='store_true')\
        .exe(lambda a: gh_push(a.path, a.clean, a.capture))

    cmd('web')\
        .exe(lambda a: sh(
            'SECRET={secret}  {root}/web.py'
            .format(secret=get_config()['secret'], root=root)
        ))

    args = parser.parse_args()
    dry_run = args.dry_run
    if not hasattr(args, 'exe'):
        parser.print_usage()
    else:
        args.exe(args)


if __name__ == '__main__':
    try:
        main()
    except KeyboardInterrupt:
        raise SystemExit(1)
