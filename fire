#!/usr/bin/env python3
import argparse
import json
import os
import random
import re
import subprocess
import sys
import urllib.request
from pathlib import Path

from common import root, log, conf, sd_containers, gh_api

dry_run = False
ssh_opts='-o "StrictHostKeyChecking no"'


def remote(cmd, host, opts=ssh_opts):
    cmd = cmd.replace('"', '\\"')
    return (
        'set -e;rsync -ahv --delete'
        ' -e \'ssh {opts}\''
        ' --exclude=.git --exclude=push --exclude=env'
        ' {root}/ {host}:{tmp}/;'
        'ssh {opts} {host} "cd {tmp}; {cmd}"'
        .format(tmp='/tmp/deploy', root=root, host=host, opts=opts, cmd=cmd)
    )


def sh(cmd, params=None, ssh=None, exit=True):
    params = params or {}
    if ssh:
        cmd = remote(cmd, ssh)

    log.info(cmd)
    if dry_run:
        log.info('Dry run!')
        return 0

    code = subprocess.call(cmd, shell=True)
    if exit and code:
        raise SystemExit(code)
    return code


def gh_request(path):
    path = Path(path) / 'request.json'
    req = json.loads(path.read_text())

    if isinstance(req, dict):
        # TODO: remove it later
        return req['headers'], req['json']
    else:
        return req


def gh_build(path, url, only_checks, only_web, **kw):
    import web

    headers, body = gh_request(path)
    ctx = web.get_ctx(headers, body, **kw)

    target = None
    if only_checks:
        ctx['install'] = False
        target = web.checks
    elif only_web:
        target = web.pubweb
    elif not url:
        target = web.build

    if target:
        loop = web.app.loop
        code = loop.run_until_complete(target(ctx))
        loop.close()
        log.info(code)
        raise SystemExit(code)

    data = json.dumps(body, indent=2, sort_keys=True).encode()
    headers['X-Hub-Signature'] = web.get_signature(data)
    headers['Content-Length'] = len(data)
    req = urllib.request.Request(url, data, headers)
    try:
        resp = urllib.request.urlopen(req)
        log.info('%s: %s', resp.status, resp.reason)
    except Exception as e:
        log.error(e)


def gh_clean():
    """
    Remove contaner if
    - pull request was closed
    - branch was removed
    otherwise keep container alive
    """
    clean = []
    for name in sd_containers():
        path = root / 'push' / name
        if not path.exists():
            clean.append(name)
            continue
        path = next(path.glob('?' * 10))
        headers, req = gh_request(path)
        event = headers.get('X-Github-Event')
        if event == 'pull_request':
            url = req['pull_request']['_links']['self']['href']
            res = gh_api(url)
            if res['state'] == 'open':
                log.info('Skip %s', name)
                continue
        elif event == 'push':
            url = req['repository']['merges_url'].rsplit('/', 1)[0]
            url = '%s/git/%s' % (url, req['ref'])
            if gh_api(url, False):
                log.info('Skip %s', name)
                continue
        else:
            log.info('Skip %s', name)
            continue
        clean.append(name)

    if not clean:
        log.info('Nothing to clean')
        return

    cmd = ';\n'.join('./fire lxc-clean "^%s"' % n for n in clean)
    sh('\n%s;\n./fire nginx' % cmd)


def update_nginx(path):
    cmd = ''
    for name in sd_containers('--running'):
        cmd += (
            '\nname={name} host={name}.{domain} . superdesk-dev/nginx.tpl;'
            .format(name=name, domain=conf['domain'])
        )
    sh(
        '({cmd}) > {path};'
        'nginx -s reload'
        .format(cmd=cmd, path=path)
    )


def cpus():
    per_lxc = conf['cpus_per_lxc']
    if not per_lxc or per_lxc < os.cpu_count():
        return ''

    cpus = [i + 1 for i in range(os.cpu_count())]
    return ','.join(str(i) for i in random.sample(cpus, per_lxc))


def main():
    global dry_run

    parser = argparse.ArgumentParser('fire')
    cmds = parser.add_subparsers(help='commands')

    def cmd(name, **kw):
        p = cmds.add_parser(name, **kw)
        p.set_defaults(cmd=name)
        p.arg = lambda *a, **kw: p.add_argument(*a, **kw) and p
        p.exe = lambda f: p.set_defaults(exe=f) and p

        p.arg('--dry-run', action='store_true')
        return p

    def ssh(ssh, lxc_name):
        return (
            ssh or
            (lxc_name and '$(lxc-info -n %s -iH)' % lxc_name)
        )

    cmd('install', aliases=['i'])\
        .arg('--lxc-name')\
        .arg('--ssh')\
        .arg('-e', '--endpoint', default='superdesk/master')\
        .arg('--prepopulate', action='store_true')\
        .arg('--services', action='store_true')\
        .arg('--env')\
        .exe(lambda a: sh(
            'services={services} '
            'prepopulate={prepopulate} '
            'action=do_install '
            '{env} '
            '{endpoint}'
            .format(
                services=a.services or '',
                prepopulate=a.prepopulate or '',
                endpoint=a.endpoint,
                env=a.env or ''
            ),
            ssh=ssh(a.ssh, a.lxc_name)
        ))

    cmd('run', aliases=['r'])\
        .arg('--lxc-name')\
        .arg('--ssh')\
        .arg('-e', '--endpoint', default='superdesk/master')\
        .arg('-a', '--action', default='')\
        .arg('--env')\
        .exe(lambda a: sh(
            'action={action!r} {env} {endpoint}'
            .format(action=a.action, endpoint=a.endpoint, env=a.env or ''),
            ssh=ssh(a.ssh, a.lxc_name)
        ))

    cmd('gh-build')\
        .arg('path')\
        .arg('-u', '--url')\
        .arg('-c', '--only-checks', action='store_true')\
        .arg('-w', '--only-web', action='store_true')\
        .arg('--clean', action='store_true')\
        .arg('--clean-web', action='store_true')\
        .exe(lambda a: gh_build(
            a.path, a.url, a.only_checks, a.only_web,
            clean=a.clean, clean_web=a.clean_web
        ))

    cmd('gh-clean', help='remove unused containers')\
        .exe(lambda a: gh_clean())

    cmd('nginx', help='update nginx config')\
        .arg('-p', '--path', default='/etc/nginx/sites-enabled/sd')\
        .exe(lambda a: update_nginx(a.path))

    cmd('gen-files')\
        .exe(lambda a: sh('bin/gen-files.sh'))

    cmd('lxc-init')\
        .arg('-n', '--name', default='sd0')\
        .arg('--rm', action='store_true')\
        .arg('-k', '--keys', default='/root/.ssh/id_rsa.pub')\
        .arg('-o', '--opts', default='')\
        .exe(lambda a: sh(
            'name={name} '
            'rm={rm} '
            'keys={keys} '
            'opts={opts!r} '
            'bin/lxc-init.sh'
            .format(name=a.name, rm=a.rm or '', opts=a.opts, keys=a.keys)
        ))

    cmd('lxc-base')\
        .arg('-n', '--name', default=conf['sdbase'])\
        .arg('-p', '--path', default='/opt/superdesk')\
        .arg('-o', '--opts', default='')\
        .exe(lambda a: sh(
            'set -ex;'
            'tmp={name}--tmp; '
            './fire lxc-init -n $tmp --rm -o {opts!r};'
            './fire i --lxc-name=$tmp -e superdesk-dev/master --services;'
            './fire lxc-ssh $tmp -c "rm -rf {path}";'
            './fire lxc-copy --no-cpus -r -c -b $tmp {name};'
            .format(name=a.name, path=a.path, opts=a.opts)
        ))

    cmd('lxc-web')\
        .arg('-n', '--name', default='sd0')\
        .arg('-d', '--domain', required=True)\
        .arg('-c', '--clean', action='store_true')\
        .exe(lambda a: sh(
            'name={name} '
            'domain={domain} '
            'clean={clean} '
            'bin/lxc-web.sh'
            .format(name=a.name, domain=a.domain, clean=a.clean or '')
        ))

    cmd('lxc-copy')\
        .arg('name')\
        .arg('-b', '--base', default=conf['sdbase'])\
        .arg('-c', '--clean', action='store_true')\
        .arg('-s', '--start', action='store_true')\
        .arg('-r', '--rename', action='store_true')\
        .arg('--no-cpus', action='store_true')\
        .arg('--no-snapshot', action='store_true')\
        .exe(lambda a: sh(
            'name={name} '
            'rename={rename} '
            'clean={clean} '
            'start={start} '
            'base={base} '
            'cpus={cpus} '
            'snapshot={snapshot} '
            'bin/lxc-copy.sh'
            .format(
                name=a.name,
                base=a.base,
                start=a.start or '',
                clean=a.clean or '',
                rename=a.rename or '',
                cpus='' if a.no_cpus else cpus(),
                snapshot='' if a.no_snapshot else 1,
            )
        ))

    cmd('lxc-rm')\
        .arg('name', nargs='+')\
        .exe(lambda a: sh('; '.join(
            'lxc-destroy -f -n {name}'
            .format(name=name)
            for name in a.name if name
        )))

    cmd('lxc-ssh')\
        .arg('name')\
        .arg('-c', '--cmd', default='')\
        .exe(lambda a: sh(
            'ssh {ssh_opts} $(lxc-info -n {name} -iH) {cmd}'
            .format(ssh_opts=ssh_opts, name=a.name, cmd=a.cmd)
        ))

    cmd('lxc-wait')\
        .arg('name')\
        .exe(lambda a: sh(
            'lxc-wait -n {name} -s RUNNING &&'
            'while ! $(./fire lxc-ssh {name} -c true > /dev/null);'
            '   do sleep 1; '
            'done'
            .format(name=a.name)
        ))

    cmd('lxc-clean')\
        .arg('pattern', default='^sd', nargs='?')\
        .exe(lambda a: sh(
            'lxc-ls -1 | grep "{pattern}" | xargs -r ./fire lxc-rm'
            .format(pattern=a.pattern)
        ))

    args = parser.parse_args()
    dry_run = args.dry_run
    if not hasattr(args, 'exe'):
        parser.print_usage()
    else:
        args.exe(args)


if __name__ == '__main__':
    try:
        if os.geteuid() != 0:
            subprocess.call(['sudo', sys.executable] + sys.argv)
        else:
            main()
    except KeyboardInterrupt:
        raise SystemExit(1)
