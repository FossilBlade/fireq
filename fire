#!/usr/bin/env python3
import argparse
import json
import logging
import os
import subprocess
import sys
import urllib.request
from pathlib import Path

log = logging.getLogger(__name__)
logging.basicConfig(
    level=logging.DEBUG,
    datefmt='%H:%M:%S',
    format='%(asctime)s %(message)s'
)
root = Path(__file__).resolve().parent
dry_run = False
ssh_opts='-o "StrictHostKeyChecking no"'


def remote(cmd, host, opts=ssh_opts):
    cmd = cmd.replace('"', '\\"')
    return (
        'set -e;rsync -ahv --delete'
        ' -e \'ssh {opts}\''
        ' --exclude=.git --exclude=push --exclude=env'
        ' {root}/ {host}:{tmp}/;'
        'ssh {opts} {host} "cd {tmp}; {cmd}"'
        .format(tmp='/tmp/deploy', root=root, host=host, opts=opts, cmd=cmd)
    )


def sh(cmd, params=None, ssh=None, exit=True):
    params = params or {}
    if ssh:
        cmd = remote(cmd, ssh)

    log.info(cmd)
    if dry_run:
        log.info('Dry run!')
        return 0

    code = subprocess.call(cmd, shell=True)
    if exit and code:
        raise SystemExit(code)
    return code


def gh_build(path, url, only_checks, only_web, **kw):
    import web

    path = Path(path)
    with (path / 'request.json').open('r') as f:
        req = json.loads(f.read())

    if isinstance(req, dict):
        # TODO: remove it later
        headers, body = req['headers'], req['json']
    else:
        headers, body = req

    web.init_conf()
    ctx = web.get_ctx(headers, body, **kw)

    target = None
    if only_checks:
        ctx['install'] = False
        target = web.checks
    elif only_web:
        target = web.pubweb
    elif not url:
        target = web.build

    if target:
        loop = web.init_loop()
        code = loop.run_until_complete(target(ctx))
        loop.close()
        log.info(code)
        raise SystemExit(code)

    data = json.dumps(body, indent=2, sort_keys=True).encode()
    headers['X-Hub-Signature'] = web.get_signature(data)
    headers['Content-Length'] = len(data)
    req = urllib.request.Request(url, data, headers)
    try:
        resp = urllib.request.urlopen(req)
        log.info('%s: %s', resp.status, resp.reason)
    except Exception as e:
        log.error(e)


def main():
    global dry_run

    parser = argparse.ArgumentParser('fire')
    cmds = parser.add_subparsers(help='commands')

    def cmd(name, **kw):
        p = cmds.add_parser(name, **kw)
        p.set_defaults(cmd=name)
        p.arg = lambda *a, **kw: p.add_argument(*a, **kw) and p
        p.exe = lambda f: p.set_defaults(exe=f) and p

        p.arg('--dry-run', action='store_true')
        return p

    def ssh(ssh, lxc_name):
        return (
            ssh or
            (lxc_name and '$(lxc-info -n %s -iH)' % lxc_name)
        )

    cmd('install', aliases=['i'])\
        .arg('--lxc-name')\
        .arg('--ssh')\
        .arg('-e', '--endpoint', default='superdesk/master')\
        .arg('--prepopulate', action='store_true')\
        .arg('--services', action='store_true')\
        .arg('--env')\
        .exe(lambda a: sh(
            'services={services} '
            'prepopulate={prepopulate} '
            'action=do_install '
            '{env} '
            '{endpoint}'
            .format(
                services=a.services or '',
                prepopulate=a.prepopulate or '',
                endpoint=a.endpoint,
                env=a.env or ''
            ),
            ssh=ssh(a.ssh, a.lxc_name)
        ))

    cmd('run', aliases=['r'])\
        .arg('--lxc-name')\
        .arg('--ssh')\
        .arg('-e', '--endpoint', default='superdesk/master')\
        .arg('-a', '--action', default='')\
        .arg('--env')\
        .exe(lambda a: sh(
            'action={action!r} {env} {endpoint}'
            .format(action=a.action, endpoint=a.endpoint, env=a.env or ''),
            ssh=ssh(a.ssh, a.lxc_name)
        ))

    cmd('gh-build')\
        .arg('path')\
        .arg('-u', '--url')\
        .arg('-c', '--only-checks', action='store_true')\
        .arg('-w', '--only-web', action='store_true')\
        .arg('--clean', action='store_true')\
        .arg('--clean-web', action='store_true')\
        .exe(lambda a: gh_build(
            a.path, a.url, a.only_checks, a.only_web,
            clean=a.clean, clean_web=a.clean_web
        ))

    cmd('gen-files')\
        .exe(lambda a: sh('bin/gen-files.sh'))

    cmd('lxc-init')\
        .arg('-n', '--name', default='sd0')\
        .arg('--rm', action='store_true')\
        .arg('-k', '--keys', default='/root/.ssh/id_rsa.pub')\
        .exe(lambda a: sh(
            'name={name} '
            'rm={rm} '
            'keys={keys} '
            'bin/lxc-init.sh'
            .format(name=a.name, rm=a.rm or '', keys=a.keys)
        ))

    cmd('lxc-web')\
        .arg('-n', '--name', default='sd0')\
        .arg('-d', '--domain', required=True)\
        .arg('-c', '--clean', action='store_true')\
        .exe(lambda a: sh(
            'name={name} '
            'domain={domain} '
            'clean={clean} '
            'bin/lxc-web.sh'
            .format(name=a.name, domain=a.domain, clean=a.clean or '')
        ))

    cmd('lxc-copy')\
        .arg('name')\
        .arg('-b', '--base', default='sdbase')\
        .arg('-c', '--clean', action='store_true')\
        .arg('-s', '--start', action='store_true')\
        .exe(lambda a: sh(
            'name={name} '
            'clean={clean} '
            'start={start} '
            'base={base} '
            'bin/lxc-copy.sh'
            .format(
                name=a.name,
                base=a.base,
                start=a.start or '',
                clean=a.clean or ''
            )
        ))

    cmd('lxc-base')\
        .arg('-n', '--name', default='sdbase')\
        .arg('-p', '--path', default='/opt/superdesk')\
        .exe(lambda a: sh(
            'set -ex;'
            'tmp={name}--tmp; '
            './fire lxc-init -n $tmp --rm;'
            './fire i --lxc-name=$tmp --services;'
            './fire lxc-ssh $tmp -c "rm -rf {path}";'
            './fire lxc-copy -c -b $tmp {name};'
            './fire lxc-rm $tmp'
            .format(name=a.name, path=a.path)
        ))

    cmd('lxc-rm')\
        .arg('name', nargs='+')\
        .exe(lambda a: sh('; '.join(
            'lxc-stop -n {name};'
            'lxc-destroy -n {name}'
            .format(name=name)
            for name in a.name if name
        )))

    cmd('lxc-ssh')\
        .arg('name')\
        .arg('-c', '--cmd', default='')\
        .exe(lambda a: sh(
            'ssh {ssh_opts} $(lxc-info -n {name} -iH) {cmd}'
            .format(ssh_opts=ssh_opts, name=a.name, cmd=a.cmd)
        ))

    cmd('lxc-wait')\
        .arg('name')\
        .exe(lambda a: sh(
            'lxc-wait -n {name} -s RUNNING &&'
            'while ! $(./fire lxc-ssh {name} -c true > /dev/null);'
            '   do sleep 1; '
            'done'
            .format(name=a.name)
        ))

    cmd('lxc-clean')\
        .arg('pattern', default='^sd', nargs='?')\
        .exe(lambda a: sh(
            'lxc-ls -1 | grep "{pattern}" | xargs ./fire lxc-rm'
            .format(pattern=a.pattern)
        ))

    args = parser.parse_args()
    dry_run = args.dry_run
    if not hasattr(args, 'exe'):
        parser.print_usage()
    else:
        args.exe(args)


if __name__ == '__main__':
    try:
        if os.geteuid() != 0:
            subprocess.call(['sudo', sys.executable] + sys.argv)
        else:
            main()
    except KeyboardInterrupt:
        raise SystemExit(1)
